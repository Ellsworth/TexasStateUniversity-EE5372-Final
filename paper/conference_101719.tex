
\documentclass[journal]{IEEEtran}

\ifCLASSINFOpdf

\else

\fi

% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

\begin{document}

\title{Implementation of the Ascon Encryption Algorithm for Secure Industrial IoT Networks}

% ~\IEEEmembership{Member,~IEEE,}
\author{Erich~Ellsworth,
        Daniyar~Boztayev,
        Priyan~Shah,
        Liam~Quinn,
        and Semih~Aslan,~\IEEEmembership{Member,~IEEE}% <-this % stops a space

    \textit{Ingram School of Engineering, Texas State University, San Marcos, Texas, USA}

}




% The paper headers
\markboth{Journal of \LaTeX\ Class Files,~Vol.~14, No.~8, August~2015}%
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for IEEE Journals}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\begin{abstract}
This paper presents a comprehensive evaluation of the Ascon encryption algorithm for secure communications in Internet of Things (IoT) networks, with a particular focus on Industrial IoT (IIoT) applications. Ascon's lightweight design offers significant advantages for low-power devices, providing both low computational overhead and resilience against quantum computing-based attacks. We explore three distinct use cases of Ascon within IoT networks and analyze security implications of these networks. Additionally, we address key implementation challenges and propose strategies for implementing Ascon in resource-constrained IoT networks.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
IEEE, IEEEtran, journal, \LaTeX, paper, template.
\end{IEEEkeywords}



\IEEEpeerreviewmaketitle



\section{Introduction}

\IEEEPARstart{T}{he} field of Industrial Internet of Things (IIoT) has proven to be a area of extreme growth potential with the rapidly shrinking cost of low-power IoT devices. A significant concern in the field of IoT is the need to secure communication in these networks, despite the limited computational and storage capacity of these devices.

A significant milestone in the advancement of IoT security is the selection of the Ascon family of encryption algorithms by the National Institute of Standards and Technology (NIST) as the standard for lightweight cryptography. ASCON was chosen for its efficiency, robustness, and suitability for resource-constrained, low-power devices. \cite{NISTAsconAnnouncement}

Ascon has already been demonstrated to be extremely effective in applications such as sensor data transmission over low power transmission mediums such as LoRa. Ascon provides significant advantages over classical algorithms such as AES, requiring significantly less memory and computational power. \cite{AsconLoRa}

Furthermore, the field of Industrial Internet of Things (IIoT) shows promise in providing increased visibility to a plant's condition, allowing operators to make real-time data-driven  decisions based off of data collected from remote, low power sensors. Current approaches integrate IIoT technologies with traditional industrial infrastructure, such as Modbus-based sensors and control systems, offering seamless interoperability between traditional Supervisory Control and Data Acquisition (SCADA) and IoT cloud infrastructure. \cite{NuratchIIoT}

The integration of Industrial Internet of Things (IIoT) systems introduces significant challenges concerning the security, integrity, and reliability of industrial processes. Unlike traditional IT environments, IIoT systems face unique risks, where cybersecurity incidents can have far-reaching consequences, including operational disruptions and threats to human safety. Prior work has provided methodologies for assessing risk associated with integrating IIoT with existing industrial processes. \cite{SecurityIIoT}

\section{Methods}

In this study, three cryptographic experiment-infrastructures were simulated and analyzed for effectiveness and safety of the network. The first experiment involved one shared key for all nodes, meaning that any node can decrypt the message upon receiving it. In the second experiment, each node had a unique key, and a central server was created to manage the flow of the data between the nodes, as well as storing the data for all the keys in the network. The third experiment involved (!!!PLACEHOLDER!!!). The goal was to understand the trade-offs between simplicity and security when designing cryptographic systems for network communication in IIoT.

The network systems were implemented using Python, with a focus on simulating node-to-node communication in an arbitrary network. The implementation was structured using object-oriented principles, with main components defined as classes to represent nodes, the server, and message objects. Each node was modeled as an instance of a Node class, which inherited from a parent AsconClient class which is responsible for cryptographic operations. This structure allowed for modification and scalability in the simulation.

\subsection{Implementation Using Python}

\subsubsection{Message Structure}
The AsconMessage structure is a data container used for transmitting data between nodes by grouping encrypted message, nonce, and associated data together. 
%Erich, if you can link that shit to pyascon that would be great - DAN

\subsubsection{AsconClient Architecture}

The AsconClient class acts as a wrapper for the already-implemented Ascon encryption algorithm in Python (pyascon). This class is responsible for performing encryption and decryption of the messages. The AsconClient is designed to isolate cryptographic operations from the rest of the system, which simplifies the use of Ascon for all the objects in the network. The AsconClient generates secret keys and nonces and stores them internally for use in other objects that use the network. The main methods include encryption and decryption. Encryption method takes message and associated data (both in bytes) as input. It generates a unique nonce and applies Ascon encryption from pyascon. The resulting ciphertext with the nonce and associated data is returned as an AsconMessage object. Decryption method accepts an AsconMessage object, and using the stored key, it verifies the authenticity of the message using the nonce and associated data. If everything matches, the method will recover the original plaintext. In the case of failure, the method returns an error or an invalid result, ensuring that unauthorized or corrupted messages cannot be decrypted successfully.

The AsconClient class is intended to be inherited by the Node class, which represents network participants. Each node uses AsconClien to handle cryptographic functions - encrypting and decrypting messages. This abstraction allows the Ascon logic to be separate from the network communication logic, creating a convenient modularity in the overall system.

\subsubsection{Node Architecture}

Each Node represents a device on the network, responsible for sending and receiving data. It inherits the cryptographic functionality from the AsconClient class, which handles all the Ascon functions such as encryption, decryption, generation of keys and nonces. The main responsibilities of the Node is to simulate a device or an agent in a network that can communicate with other nodes. Each node can send encrypted messages to a recipient and decrypt messages it receives. Each Node object is assigned with a unique ID upon initialization, which is used to distinguish nodes in the network. 

Message handling includes several methods for message transmission and reception, along with error handling. The \textit{send\_message} method simulates the process of sending an encrypted message to another node. The method takes the recipient node, the message, and associated data as input. The message is then encrypted using the node's own key (handled by the AsconClient's encrypt method) before being transmitted to the recipient node. The \textit{receive\_message} method simulates the reception of an encrypted message. Upon receiving a message, a node attempts to decrypt it using the decrypt method from AsconClient. If the decryption is successful, the node retrieves message and associated data. If not, the node will either report that the decryption failed, or will return a message of None type. 



%\subsection{Fixed Variables}

\subsection{Network Traversal}
%Erich you would write this section a lot better imho - DAN
\subsubsection{Overhead?}

\subsection{Experiment 1 - Shared Key System}
The objective of this experiment was to evaluate the security and performance of a system in which the key is shared across all the nodes in the network. The approach evaluated in terms of performance and security vulnerabilities, specifically when an unautharized node attempts to intercept and decrypt messages.

In the shared key system, each node in network is initialized with the same master key. This key is used for both encrypting outgoing messages and decrypting incoming messages, meaning that all nodes share the ability to read each other's communications. The simplicity of this setup makes it ideal for environments where ease of implementation and low computational overhead are prioratized, but it also introduces significant security risks.

To simulate and evaluate the system, the Pyton-based function was created. The experiment utilized three main components described previously: Node class for representing network participants, AsconClient class to handle all cryptographic operations, and AsconMessage to encapsulate encrypted messages. The points of analysis in this experiment included the ease of message transmission using a shared key, the security risks that come with it, and the trade-off between simplicity and security.

At the beginning of the function, five nodes are initialized. Each node represents an individual entity in the network capable of sending and receiving messages. The key is randomly generated once at the start of the experiment function and is then passed to all nodes during initialization. Once the nodes are initialized, the communication between different pairs of nodes is simulated to demonstrate that the system works. In our case, we simulated two communications - one from Node 1 to Node 3 to demonstrate an arbitrary communication between two nodes, and one from Node 2 to Node 5. To assess the security of the shared key system, we introduced an interception scenario. In this setup, another node in the network is being hacked by a third-party and the hacker is able to acquire the key of the node. The hacked node then attempts to intercept and decrypt a message that was not intended for it. Since all nodes share the same key, Node 4 is able to decrpypt any intercepted message.

\subsubsection{Security Analysis} %Dan's comment - should put it in the results & discussion section but for now I'm gonna keep it here.
The primary security flaw of the shared key system is that it lacks any form of access control. Since all nodes use the same key, compromising one node effectively compromises the entire network. The interception scenario demonstrated that any node could decrypt any message, regardless of whether the message was intended for that node. This makes the system highly vulnerable to attacks, particularly in environments where nodes maybe exposed to untrusted networks or where unauthorized access is a concern. 

\subsection{Experiment 2 - Unique Key System with Central Server}

\subsection{Experiment 3}

\section{Results \& Discussion}


% Can use something like this to put references on a page
% by themselves when using endfloat and the captionsoff option.
\ifCLASSOPTIONcaptionsoff
  \newpage
\fi



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,paper/bibtex}

% that's all folks
\end{document}
